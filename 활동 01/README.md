# 활동 01 과제

# 자바 기본 프로그래밍

## 자바의 데이터 타입

### 데이터 타입이란?
자료형. 변수명 앞의 int, String 등. 변수의 앞에 쓰여 변수의 자료형을 지정해줌. 자바의 데이터 타입의 크기는 CPU나 운영체제에 따라 **변하지 않는다.**

### 자주 쓰이는 자료형
- int
- long
- double
- boolean
- char
- String
- StringBuffer
- List
- Map
위와 같은 primitives type이 있고 아래처럼 사용자 정의 자료형도 있다.
> class Animal {<br>
  psvm{Animal cat;}<br>
}


### 레퍼런스 타입
primitives type과 다른 형태로 references type이 있다. 레퍼런스 타입에는 배열 타입, 열거 타입, 클래스, 인터페이스 등이 있다.

### 자바의 데이터 타입
![자바 데이터 타입](https://t1.daumcdn.net/cfile/tistory/9990144E5AB240FC20)


## 상수

### 상수 선언
상수 선언 시 주의사항은 아래와 같다.
- final 키워드 사용
> final double PI = 3.141592;

- 선언 시 초기값 지정
- 실행 중 값 변경 불가
상수 이름은 보통 **모든 문자를 대문자**로 표시한다.



# 반복문과 배열 그리고 예외처리

## main() 메소드 원형
main() method의 형태는 아래와 같다.
> public static void main(String[] args)

자바도 C와 마찬가지로 가장 먼저 시작하는 시작점. Entry point가 있다. C의 main()함수처럼 자바는 main()메소드가 있다. 
> public

public은 공개 범위를 나타낸다. 이 위치에는 public, protected, private가 올 수 있다. 하지만 public이 아닌 것으로 지정할 경우 다른 클래스로부터의 접근에 문제가 생겨 main으로서의 기능을 상실하므로 public으로 지정한다.
> static

static은 프로그래밍이 시작한 후에 따로 인스턴스 하지 않아도 시작과 동시에 메모리에 호출이 된다. (JVM의 GarbageCollector로 인해 클래스, 메소드, 변수 등은 일정 용도를 끝마친 후에 메모리에서 삭제가 되거나 다른 부분에서 참조가 되지 않는다.)
> void

메소드에 return 값이 없다는 뜻이다. 이유는 C언어에서와 같다.
> String[] args

프로그램이 시작되자마자 받는 특정한 값을 String type의 배열에 저장해 프로그램 안에서 사용할 수 있다. 프로그램의 실행 순간, 외부값을 가져와서 프로그램 안에 사용하고자 할 때 메모리에 저장할 공간을 미리 선언해 두는 것이라고 할 수 있다.<br>
문자열 이름은 꼭 args일 필요는 없다.


# 클래스와 객체

## 객체 지향의 특징

### 추상화
객체들의 공통적인 특징(속성과 기능)을 뽑아내는 것. 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다. <br>
절차지향 프로그래밍에서 추상화는 구조체와 같은 사용자 데이터형으로 존재한다.<br>
하나의 새로운 데이터타입을 정의하는데 그 안에 여러 개의 부속데이터를 둘 수 있다. 이 때, 그 데이터를 추상화를 통해 정의한 것이다.

### 캡슐화
객체지향에서 캡슐화는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다. 특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다. 객체가 맡은 역할을 수행하기 위한 하나의 목적을 위해 데이터와 기능들을 묶는 것이다.<br>
또한, 이러한 특징은 다른 의미로 사용되기도 한다. 데이터를 은닉하고 그 데이터를 접근하는 기능을 노출시키지 않는다는 의미로 사용할 때 캡슐화라는 용어를 사용한다. 

### 정보은닉성
캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.

### 상속
상속이란 상위개념의 특징을 하위 개념이 물려받는 것을 말한다. 하나의 클래스가 갖고 있는 특징(필드와 메소드)들을 그대로 다른 클래스에게 물려주고자 할 때 상속한다.

### 다형성
같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현한다. 
- 메소드 오버로딩: 같은 이름이지만 다르게 작동하는 여러 메소드
- 메소드 오버라이딩: 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현한다.

[객체지향의 특징](https://velog.io/@jonah/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%96%B8%EC%96%B4%EC%9D%98-%ED%8A%B9%EC%A7%95)

## 절차 지향과 객체 지향

### 절차 지향
순차적인 처리로, 작업 순서대로 표현된 것이 특징이다.<br>
작업을 함수로 작성한 함수들의 집합이다.
#### 장점
- 컴퓨터의 처리구조와 유사해 실행속도가 빠름
#### 단점
- 유지보수가 어려움
- 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움
- 디버깅이 어려움

### 객체 지향
실제 세계를 모델링하여 소프트웨어를 개발하는 방법이다.<br>
데이터와 절차를 하나의 덩어리로 묶어서 생각한다.
#### 장점
- 코드의 재활용성이 높음
- 코딩이 절차 지향보다 간편함
- 디버깅이 쉬움
#### 단점
- 처리속도가 절차 지향보다 느림
- 설계에 많은 시간소요

### 객체지향과 절차지향의 차이
절차지향은 데이터를  중심으로 함수를 구현한다. 객체지향은 기능을 중심으로 메소드를 구현한다. 
" "| 절차지향 | 객체지향
---|:---:|---:
접근방식 | 시스템 동작 방식을 먼저 생각, 그 다음 세부 모델 디자인 | 세부 보델 디자인 후 조립
구현관점 | 전체적인 기능 동작을 고려. 각 단계별로 기능을 구현. | 필요한 속성의 객체를 설계(보안성, 데이터, 함수 등). 각 객체의 상호작용(절차)을 설계
구성 요소 | 함수 | 객체
접근제어 | 없음(전부 public) | public, protected, private
오버로딩, 다형성 | 불가능 | 함수, 생성자, 연산자 등을 오버로딩 가능
상속 | 불가능 | 가능(public, protected, private)
보안성 | 낮음 | 높음
데이터 공유 | 모든 함수가 공유 가능 | 객체 간 멤버함수로만 공유
friend 함수 | 없음 | C++에 있음
가상 클래스, 가상 함수 | 없음 | 상속 개념 아래 존재함
예시 언어 | C, Visual Basic, Fortran, Pascal | C++, Java, VB.NET, C#, Python
장점 | 컴퓨터 눈높이로 구성된 문법, 바닥부터 입맛대로 설계하기 좋음 | 인간 눈높이에서 구조 파악하기 좋음, 객체 기능 제공하므로 코드 절약
단점 | 프로젝트가 커질 시 구조가 복잡해지고 중복 코드를 작성할 수도 있음 | 제공된 객체 기능에서 발생하는 오버헤드를 최적화할 수 없다면 상대적으로 느려짐
용도 | 자원이 한정되어 있거나 바닥부터 설계할 필요가 있는 프로젝트 | 규모가 크고 협업이 잦으며 생산성이 중시되는 프로젝트

## 클래스, 객체, 인스턴스

### 비교
클래스에 의해 만들어진 객체를 인스턴스라고도 한다. 그렇다면 객체와 인스턴스의 차이는 무엇인가. 
> Animal cat = new Animal(); 

이렇게 만들어진 cat은 객체이다. 그리고 cat이라는 객체는 Animal의 인스턴스이다. 즉 인스턴스라는 말은 특정 객체 cat 이 어떤 클래스 Animal의 객체인지를 관계위주로 설명할 때 사용된다. 즉, cat은 객체 ( ~~cat은 인스턴스~~ ), cat은 Animal의 인스턴스 ( ~~cat은 Animal의 객체~~ ).

### 객체 생성, 동작
main()은 Stack에, 클래스를 통해 생성된 객체는 Heap에 있다.    
참조 순서를 살펴보면 프로그램 동작 시 메인함수가 실행된다. 메인함수에 있는 '사람'이라는 객체를 이용할 수 있는 리모콘이 만들어진다. 이 리모콘은 클래스를 통해 생성된 heap이라는 영역에 잇는 사람 객체를 조종할 수 있다.     
또한 메인 함수를 통해 선언된 객체에 대한 여러 변수들도 메인 함수의 변수들로 지정되는 것이 아니라 객체 안에서 만들어진다.


## 클래스의 구성
클래스는 필드(Field), 생성자(Constructor), 메소드(Method)로 구성된다. 클래스를 선언할 때, 이들은 생략되거나 여러 개가 선언될 수 있다.<br>
[자세한 설명](https://yolojeb.tistory.com/5)


## 생성자
객체가 생성될 때, 메모리를 할당한 후 **생성자**를 호출한다. 
- 메소드이다.
- 클래스의 이름과 같은 이름을 지닌다.
- 리턴하지도 않고, 리턴 타입도 선언되지 않는다.
- 주로 객체 생성 시 멤버 변수를 원하는 값으로 초기화하기 위한 용도로 사용된다.

### 생성자와 기본 생성자의 특징
- 생성자를 하나도 정의하지 않으면 기본 생성자가 자동 삽입된다. <br>
생성자를 만들지 않았을 때 생기는 기본 생성자는 보이지 않는다. 컴파일러가 만들고 실행해주기 때문에 컴파일러 이전에 있는 코드에는 변화가 없음.
- 생성자도 메소드이므로 오버로딩이 가능하다.
- 생성자도 메소드이므로 디폴트 매개 변수의 설정이 가능하다.

## this와 this()

### this
> 객체 자신에 대한 레퍼런스이다.
>> 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨    
>> this.[member] 형태로 멤버 사용

this의 필요성은 아래와 같다. 
- 객체의 멤버 변수와 메소드 변수의 이름이 같은 경우
- 다른 메소드 호출 시 객체 자신의 레퍼런스를 전달할 때
- 메소드가 객체 자신의 레퍼런스를 반환할 때

### this()
- 클래스 내의 다른 생성자 호출
- 생성자 내에서만 사용 가능
- 반드시 생성자 코드의 제일 처음에 수행
> this(title, author);



# 궁금한 점
## 예제 3-17
- [x]
예제 3-17의 16행 
> scan.next();

부분에서 입력 스트림에 있는 정수가 아닌 토큰을 버린다고 하는데 작동원리가 궁금함. 
[이거인듯](https://medium.com/@kimddub/java-scanner-%EB%B2%84%ED%8D%BC-%EB%B9%84%EC%9A%B0%EA%B8%B0-913c652cc144)
